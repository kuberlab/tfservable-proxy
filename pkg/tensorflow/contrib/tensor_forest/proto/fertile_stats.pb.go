// Code generated by protoc-gen-go. DO NOT EDIT.
// source: tensorflow/contrib/tensor_forest/proto/fertile_stats.proto

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	tensorflow/contrib/tensor_forest/proto/fertile_stats.proto
	tensorflow/contrib/tensor_forest/proto/tensor_forest_params.proto

It has these top-level messages:
	FertileStats
	GiniStats
	LeafStat
	FertileSlot
	SplitCandidate
	SplitPruningConfig
	SplitFinishConfig
	LinearParam
	ExponentialParam
	ThresholdParam
	DepthDependentParam
	TensorForestParams
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import tensorflow_decision_trees "github.com/kuberlab/tfservable-proxy/pkg/tensorflow/contrib/decision_trees/proto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto1.ProtoPackageIsVersion2 // please upgrade the proto package

type FertileStats struct {
	// Tracks stats for each node.  node_to_slot[i] is the FertileSlot for node i.
	// This may be sized to max_nodes initially, or grow dynamically as needed.
	NodeToSlot []*FertileSlot `protobuf:"bytes,1,rep,name=node_to_slot,json=nodeToSlot" json:"node_to_slot,omitempty"`
}

func (m *FertileStats) Reset()                    { *m = FertileStats{} }
func (m *FertileStats) String() string            { return proto1.CompactTextString(m) }
func (*FertileStats) ProtoMessage()               {}
func (*FertileStats) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *FertileStats) GetNodeToSlot() []*FertileSlot {
	if m != nil {
		return m.NodeToSlot
	}
	return nil
}

type GiniStats struct {
	// This allows us to quickly track and calculate impurity (classification)
	//  by storing the sum of input weights and the sum of the squares of the
	// input weights.  Weighted gini is then: 1 - (square / sum * sum).
	// Updates to these numbers are:
	//   old_i = leaf->value(label)
	//   new_i = old_i + incoming_weight
	//   sum -> sum + incoming_weight
	//   square -> square - (old_i ^ 2) + (new_i ^ 2)
	//   total_left_sum -> total_left_sum - old_left_i * old_total_i +
	//                                      new_left_i * new_total_i
	Square float32 `protobuf:"fixed32,2,opt,name=square" json:"square,omitempty"`
}

func (m *GiniStats) Reset()                    { *m = GiniStats{} }
func (m *GiniStats) String() string            { return proto1.CompactTextString(m) }
func (*GiniStats) ProtoMessage()               {}
func (*GiniStats) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *GiniStats) GetSquare() float32 {
	if m != nil {
		return m.Square
	}
	return 0
}

type LeafStat struct {
	// The sum of the weights of the training examples that we have seen.
	// This is here, outside of the leaf_stat oneof, because almost all
	// types will want it.
	WeightSum float32 `protobuf:"fixed32,3,opt,name=weight_sum,json=weightSum" json:"weight_sum,omitempty"`
	// Types that are valid to be assigned to LeafStat:
	//	*LeafStat_Classification
	//	*LeafStat_Regression
	LeafStat isLeafStat_LeafStat `protobuf_oneof:"leaf_stat"`
}

func (m *LeafStat) Reset()                    { *m = LeafStat{} }
func (m *LeafStat) String() string            { return proto1.CompactTextString(m) }
func (*LeafStat) ProtoMessage()               {}
func (*LeafStat) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isLeafStat_LeafStat interface {
	isLeafStat_LeafStat()
}

type LeafStat_Classification struct {
	Classification *LeafStat_GiniImpurityClassificationStats `protobuf:"bytes,1,opt,name=classification,oneof"`
}
type LeafStat_Regression struct {
	Regression *LeafStat_LeastSquaresRegressionStats `protobuf:"bytes,2,opt,name=regression,oneof"`
}

func (*LeafStat_Classification) isLeafStat_LeafStat() {}
func (*LeafStat_Regression) isLeafStat_LeafStat()     {}

func (m *LeafStat) GetLeafStat() isLeafStat_LeafStat {
	if m != nil {
		return m.LeafStat
	}
	return nil
}

func (m *LeafStat) GetWeightSum() float32 {
	if m != nil {
		return m.WeightSum
	}
	return 0
}

func (m *LeafStat) GetClassification() *LeafStat_GiniImpurityClassificationStats {
	if x, ok := m.GetLeafStat().(*LeafStat_Classification); ok {
		return x.Classification
	}
	return nil
}

func (m *LeafStat) GetRegression() *LeafStat_LeastSquaresRegressionStats {
	if x, ok := m.GetLeafStat().(*LeafStat_Regression); ok {
		return x.Regression
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LeafStat) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), func(msg proto1.Message) (n int), []interface{}) {
	return _LeafStat_OneofMarshaler, _LeafStat_OneofUnmarshaler, _LeafStat_OneofSizer, []interface{}{
		(*LeafStat_Classification)(nil),
		(*LeafStat_Regression)(nil),
	}
}

func _LeafStat_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*LeafStat)
	// leaf_stat
	switch x := m.LeafStat.(type) {
	case *LeafStat_Classification:
		b.EncodeVarint(1<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Classification); err != nil {
			return err
		}
	case *LeafStat_Regression:
		b.EncodeVarint(2<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Regression); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("LeafStat.LeafStat has unexpected type %T", x)
	}
	return nil
}

func _LeafStat_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*LeafStat)
	switch tag {
	case 1: // leaf_stat.classification
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(LeafStat_GiniImpurityClassificationStats)
		err := b.DecodeMessage(msg)
		m.LeafStat = &LeafStat_Classification{msg}
		return true, err
	case 2: // leaf_stat.regression
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(LeafStat_LeastSquaresRegressionStats)
		err := b.DecodeMessage(msg)
		m.LeafStat = &LeafStat_Regression{msg}
		return true, err
	default:
		return false, nil
	}
}

func _LeafStat_OneofSizer(msg proto1.Message) (n int) {
	m := msg.(*LeafStat)
	// leaf_stat
	switch x := m.LeafStat.(type) {
	case *LeafStat_Classification:
		s := proto1.Size(x.Classification)
		n += proto1.SizeVarint(1<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *LeafStat_Regression:
		s := proto1.Size(x.Regression)
		n += proto1.SizeVarint(2<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// TODO(thomaswc): Move the GiniStats out of LeafStats and into something
// that only tracks them for splits.
type LeafStat_GiniImpurityClassificationStats struct {
	// Types that are valid to be assigned to Counts:
	//	*LeafStat_GiniImpurityClassificationStats_DenseCounts
	//	*LeafStat_GiniImpurityClassificationStats_SparseCounts
	Counts isLeafStat_GiniImpurityClassificationStats_Counts `protobuf_oneof:"counts"`
	Gini   *GiniStats                                        `protobuf:"bytes,3,opt,name=gini" json:"gini,omitempty"`
}

func (m *LeafStat_GiniImpurityClassificationStats) Reset() {
	*m = LeafStat_GiniImpurityClassificationStats{}
}
func (m *LeafStat_GiniImpurityClassificationStats) String() string { return proto1.CompactTextString(m) }
func (*LeafStat_GiniImpurityClassificationStats) ProtoMessage()    {}
func (*LeafStat_GiniImpurityClassificationStats) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{2, 0}
}

type isLeafStat_GiniImpurityClassificationStats_Counts interface {
	isLeafStat_GiniImpurityClassificationStats_Counts()
}

type LeafStat_GiniImpurityClassificationStats_DenseCounts struct {
	DenseCounts *tensorflow_decision_trees.Vector `protobuf:"bytes,1,opt,name=dense_counts,json=denseCounts,oneof"`
}
type LeafStat_GiniImpurityClassificationStats_SparseCounts struct {
	SparseCounts *tensorflow_decision_trees.SparseVector `protobuf:"bytes,2,opt,name=sparse_counts,json=sparseCounts,oneof"`
}

func (*LeafStat_GiniImpurityClassificationStats_DenseCounts) isLeafStat_GiniImpurityClassificationStats_Counts() {
}
func (*LeafStat_GiniImpurityClassificationStats_SparseCounts) isLeafStat_GiniImpurityClassificationStats_Counts() {
}

func (m *LeafStat_GiniImpurityClassificationStats) GetCounts() isLeafStat_GiniImpurityClassificationStats_Counts {
	if m != nil {
		return m.Counts
	}
	return nil
}

func (m *LeafStat_GiniImpurityClassificationStats) GetDenseCounts() *tensorflow_decision_trees.Vector {
	if x, ok := m.GetCounts().(*LeafStat_GiniImpurityClassificationStats_DenseCounts); ok {
		return x.DenseCounts
	}
	return nil
}

func (m *LeafStat_GiniImpurityClassificationStats) GetSparseCounts() *tensorflow_decision_trees.SparseVector {
	if x, ok := m.GetCounts().(*LeafStat_GiniImpurityClassificationStats_SparseCounts); ok {
		return x.SparseCounts
	}
	return nil
}

func (m *LeafStat_GiniImpurityClassificationStats) GetGini() *GiniStats {
	if m != nil {
		return m.Gini
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LeafStat_GiniImpurityClassificationStats) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), func(msg proto1.Message) (n int), []interface{}) {
	return _LeafStat_GiniImpurityClassificationStats_OneofMarshaler, _LeafStat_GiniImpurityClassificationStats_OneofUnmarshaler, _LeafStat_GiniImpurityClassificationStats_OneofSizer, []interface{}{
		(*LeafStat_GiniImpurityClassificationStats_DenseCounts)(nil),
		(*LeafStat_GiniImpurityClassificationStats_SparseCounts)(nil),
	}
}

func _LeafStat_GiniImpurityClassificationStats_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*LeafStat_GiniImpurityClassificationStats)
	// counts
	switch x := m.Counts.(type) {
	case *LeafStat_GiniImpurityClassificationStats_DenseCounts:
		b.EncodeVarint(1<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.DenseCounts); err != nil {
			return err
		}
	case *LeafStat_GiniImpurityClassificationStats_SparseCounts:
		b.EncodeVarint(2<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.SparseCounts); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("LeafStat_GiniImpurityClassificationStats.Counts has unexpected type %T", x)
	}
	return nil
}

func _LeafStat_GiniImpurityClassificationStats_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*LeafStat_GiniImpurityClassificationStats)
	switch tag {
	case 1: // counts.dense_counts
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(tensorflow_decision_trees.Vector)
		err := b.DecodeMessage(msg)
		m.Counts = &LeafStat_GiniImpurityClassificationStats_DenseCounts{msg}
		return true, err
	case 2: // counts.sparse_counts
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(tensorflow_decision_trees.SparseVector)
		err := b.DecodeMessage(msg)
		m.Counts = &LeafStat_GiniImpurityClassificationStats_SparseCounts{msg}
		return true, err
	default:
		return false, nil
	}
}

func _LeafStat_GiniImpurityClassificationStats_OneofSizer(msg proto1.Message) (n int) {
	m := msg.(*LeafStat_GiniImpurityClassificationStats)
	// counts
	switch x := m.Counts.(type) {
	case *LeafStat_GiniImpurityClassificationStats_DenseCounts:
		s := proto1.Size(x.DenseCounts)
		n += proto1.SizeVarint(1<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *LeafStat_GiniImpurityClassificationStats_SparseCounts:
		s := proto1.Size(x.SparseCounts)
		n += proto1.SizeVarint(2<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// This is the info needed for calculating variance for regression.
// Variance will still have to be summed over every output, but the
// number of outputs in regression problems is almost always 1.
type LeafStat_LeastSquaresRegressionStats struct {
	MeanOutput        *tensorflow_decision_trees.Vector `protobuf:"bytes,1,opt,name=mean_output,json=meanOutput" json:"mean_output,omitempty"`
	MeanOutputSquares *tensorflow_decision_trees.Vector `protobuf:"bytes,2,opt,name=mean_output_squares,json=meanOutputSquares" json:"mean_output_squares,omitempty"`
}

func (m *LeafStat_LeastSquaresRegressionStats) Reset()         { *m = LeafStat_LeastSquaresRegressionStats{} }
func (m *LeafStat_LeastSquaresRegressionStats) String() string { return proto1.CompactTextString(m) }
func (*LeafStat_LeastSquaresRegressionStats) ProtoMessage()    {}
func (*LeafStat_LeastSquaresRegressionStats) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{2, 1}
}

func (m *LeafStat_LeastSquaresRegressionStats) GetMeanOutput() *tensorflow_decision_trees.Vector {
	if m != nil {
		return m.MeanOutput
	}
	return nil
}

func (m *LeafStat_LeastSquaresRegressionStats) GetMeanOutputSquares() *tensorflow_decision_trees.Vector {
	if m != nil {
		return m.MeanOutputSquares
	}
	return nil
}

type FertileSlot struct {
	// The statistics for *all* the examples seen at this leaf.
	LeafStats  *LeafStat         `protobuf:"bytes,4,opt,name=leaf_stats,json=leafStats" json:"leaf_stats,omitempty"`
	Candidates []*SplitCandidate `protobuf:"bytes,1,rep,name=candidates" json:"candidates,omitempty"`
	// The statistics for the examples seen at this leaf after all the
	// splits have been initialized.  If post_init_leaf_stats.weight_sum
	// is > 0, then all candidates have been initialized.  We need to track
	// both leaf_stats and post_init_leaf_stats because the first is used
	// to create the decision_tree::Leaf and the second is used to infer
	// the statistics for the right side of a split (given the leaf side
	// stats).
	PostInitLeafStats *LeafStat `protobuf:"bytes,6,opt,name=post_init_leaf_stats,json=postInitLeafStats" json:"post_init_leaf_stats,omitempty"`
	NodeId            int32     `protobuf:"varint,5,opt,name=node_id,json=nodeId" json:"node_id,omitempty"`
	Depth             int32     `protobuf:"varint,7,opt,name=depth" json:"depth,omitempty"`
}

func (m *FertileSlot) Reset()                    { *m = FertileSlot{} }
func (m *FertileSlot) String() string            { return proto1.CompactTextString(m) }
func (*FertileSlot) ProtoMessage()               {}
func (*FertileSlot) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *FertileSlot) GetLeafStats() *LeafStat {
	if m != nil {
		return m.LeafStats
	}
	return nil
}

func (m *FertileSlot) GetCandidates() []*SplitCandidate {
	if m != nil {
		return m.Candidates
	}
	return nil
}

func (m *FertileSlot) GetPostInitLeafStats() *LeafStat {
	if m != nil {
		return m.PostInitLeafStats
	}
	return nil
}

func (m *FertileSlot) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *FertileSlot) GetDepth() int32 {
	if m != nil {
		return m.Depth
	}
	return 0
}

type SplitCandidate struct {
	// proto representing the potential node.
	Split *tensorflow_decision_trees.BinaryNode `protobuf:"bytes,1,opt,name=split" json:"split,omitempty"`
	// Right counts are inferred from FertileSlot.leaf_stats and left.
	LeftStats *LeafStat `protobuf:"bytes,4,opt,name=left_stats,json=leftStats" json:"left_stats,omitempty"`
	// Right stats (not full counts) are kept here.
	RightStats *LeafStat `protobuf:"bytes,5,opt,name=right_stats,json=rightStats" json:"right_stats,omitempty"`
	// Fields used when training with a graph runner.
	UniqueId string `protobuf:"bytes,6,opt,name=unique_id,json=uniqueId" json:"unique_id,omitempty"`
}

func (m *SplitCandidate) Reset()                    { *m = SplitCandidate{} }
func (m *SplitCandidate) String() string            { return proto1.CompactTextString(m) }
func (*SplitCandidate) ProtoMessage()               {}
func (*SplitCandidate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SplitCandidate) GetSplit() *tensorflow_decision_trees.BinaryNode {
	if m != nil {
		return m.Split
	}
	return nil
}

func (m *SplitCandidate) GetLeftStats() *LeafStat {
	if m != nil {
		return m.LeftStats
	}
	return nil
}

func (m *SplitCandidate) GetRightStats() *LeafStat {
	if m != nil {
		return m.RightStats
	}
	return nil
}

func (m *SplitCandidate) GetUniqueId() string {
	if m != nil {
		return m.UniqueId
	}
	return ""
}

func init() {
	proto1.RegisterType((*FertileStats)(nil), "tensorflow.tensorforest.FertileStats")
	proto1.RegisterType((*GiniStats)(nil), "tensorflow.tensorforest.GiniStats")
	proto1.RegisterType((*LeafStat)(nil), "tensorflow.tensorforest.LeafStat")
	proto1.RegisterType((*LeafStat_GiniImpurityClassificationStats)(nil), "tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats")
	proto1.RegisterType((*LeafStat_LeastSquaresRegressionStats)(nil), "tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats")
	proto1.RegisterType((*FertileSlot)(nil), "tensorflow.tensorforest.FertileSlot")
	proto1.RegisterType((*SplitCandidate)(nil), "tensorflow.tensorforest.SplitCandidate")
}

func init() {
	proto1.RegisterFile("tensorflow/contrib/tensor_forest/proto/fertile_stats.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 664 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x95, 0x4f, 0x4f, 0xdb, 0x4c,
	0x10, 0xc6, 0x31, 0x90, 0x40, 0xc6, 0xbc, 0x48, 0xf8, 0x45, 0x25, 0x02, 0x55, 0x4d, 0xd3, 0x56,
	0xe4, 0x82, 0x2d, 0xa5, 0x52, 0x0f, 0xad, 0x2a, 0xd1, 0x20, 0x01, 0x91, 0x10, 0x15, 0x4e, 0xc5,
	0xa1, 0x17, 0xcb, 0xd8, 0x63, 0xb3, 0xc2, 0xd9, 0x35, 0xbb, 0xe3, 0x22, 0x3e, 0x4b, 0xbf, 0x46,
	0x2f, 0xfd, 0x56, 0x3d, 0x56, 0xea, 0xa5, 0xf2, 0xae, 0xf3, 0x87, 0x96, 0x40, 0xd4, 0x9b, 0x77,
	0x32, 0xcf, 0x6f, 0x9e, 0x99, 0x59, 0x3b, 0xf0, 0x96, 0x90, 0x2b, 0x21, 0x93, 0x4c, 0xdc, 0x78,
	0x91, 0xe0, 0x24, 0xd9, 0x85, 0x67, 0x42, 0x41, 0x22, 0x24, 0x2a, 0xf2, 0x72, 0x29, 0x48, 0x78,
	0x09, 0x4a, 0x62, 0x19, 0x06, 0x8a, 0x42, 0x52, 0xae, 0x8e, 0x39, 0x5b, 0x13, 0xad, 0x5b, 0x3d,
	0x6a, 0xc9, 0xf6, 0xfe, 0x3d, 0xd0, 0x18, 0x23, 0xa6, 0x98, 0xe0, 0x01, 0x49, 0x44, 0x55, 0x51,
	0x53, 0xe4, 0x28, 0x59, 0xa4, 0x63, 0xc1, 0x50, 0xc4, 0x98, 0x19, 0x74, 0xfb, 0x1c, 0xd6, 0x0e,
	0x4d, 0xc5, 0x41, 0x59, 0xd0, 0x39, 0x84, 0x35, 0x2e, 0x62, 0x0c, 0x48, 0x04, 0x2a, 0x13, 0xd4,
	0xb4, 0x5a, 0x4b, 0x1d, 0xbb, 0xfb, 0xd2, 0x9d, 0xe1, 0xc0, 0x1d, 0x89, 0x33, 0x41, 0x3e, 0x94,
	0xca, 0x4f, 0xa2, 0x7c, 0x6e, 0xbf, 0x80, 0xc6, 0x11, 0xe3, 0xcc, 0x40, 0x9f, 0x40, 0x5d, 0x5d,
	0x17, 0xa1, 0xc4, 0xe6, 0x62, 0xcb, 0xea, 0x2c, 0xfa, 0xd5, 0xa9, 0xfd, 0xbd, 0x06, 0xab, 0x27,
	0x18, 0x26, 0x65, 0x96, 0xf3, 0x14, 0xe0, 0x06, 0x59, 0x7a, 0x49, 0x81, 0x2a, 0x86, 0xcd, 0x25,
	0x9d, 0xd8, 0x30, 0x91, 0x41, 0x31, 0x74, 0xae, 0x60, 0x3d, 0xca, 0x42, 0xa5, 0x58, 0xc2, 0xa2,
	0x90, 0x98, 0xe0, 0x4d, 0xab, 0x65, 0x75, 0xec, 0xee, 0x87, 0x99, 0xd6, 0x46, 0x64, 0xb7, 0x34,
	0xd2, 0x1f, 0xe6, 0x85, 0x64, 0x74, 0x7b, 0x70, 0x87, 0xa1, 0xed, 0x1d, 0x2f, 0xf8, 0x7f, 0xa0,
	0x9d, 0x00, 0x40, 0x62, 0x2a, 0x51, 0x95, 0x83, 0xd4, 0xa6, 0xed, 0xee, 0xfb, 0xc7, 0x0b, 0x9d,
	0x60, 0xa8, 0x68, 0xa0, 0x7b, 0x53, 0xfe, 0x58, 0x3f, 0x2a, 0x32, 0x85, 0xdc, 0xfe, 0x65, 0xc1,
	0xb3, 0x47, 0x6c, 0x95, 0xab, 0x88, 0x91, 0x2b, 0x0c, 0x22, 0x51, 0x70, 0x52, 0x55, 0xbf, 0xcf,
	0xa7, 0x6d, 0xdc, 0xdd, 0xb5, 0x7b, 0x8e, 0x11, 0x09, 0x79, 0xbc, 0xe0, 0xdb, 0x5a, 0x78, 0xa0,
	0x75, 0xce, 0x29, 0xfc, 0xa7, 0xf2, 0x50, 0x4e, 0x40, 0xa6, 0x9f, 0xdd, 0x07, 0x40, 0x03, 0x9d,
	0x3f, 0xc6, 0xad, 0x19, 0x7d, 0xc5, 0x7b, 0x03, 0xcb, 0x29, 0xe3, 0x4c, 0xaf, 0xc8, 0xee, 0xb6,
	0x67, 0x8e, 0x65, 0xbc, 0x7f, 0x5f, 0xe7, 0xf7, 0x56, 0xa1, 0x6e, 0x0c, 0x6c, 0x7f, 0xb3, 0x60,
	0xe7, 0x81, 0x59, 0x39, 0x3d, 0xb0, 0x87, 0x18, 0xf2, 0x40, 0x14, 0x94, 0x17, 0x34, 0x77, 0xe3,
	0x3e, 0x94, 0xaa, 0x8f, 0x5a, 0xe4, 0x9c, 0xc1, 0xff, 0x53, 0x8c, 0xc0, 0xdc, 0xb8, 0x51, 0xef,
	0x73, 0xb0, 0x36, 0x26, 0xac, 0xca, 0x65, 0xcf, 0x86, 0x46, 0x86, 0x61, 0xa2, 0x5f, 0xcd, 0xf6,
	0xd7, 0x45, 0xb0, 0xa7, 0x2e, 0xbf, 0xb3, 0x0f, 0x30, 0xfe, 0x51, 0x35, 0x97, 0xff, 0x2e, 0x73,
	0xef, 0x95, 0xf1, 0x35, 0xd1, 0x74, 0x7d, 0x04, 0x10, 0x85, 0x3c, 0x66, 0x71, 0x48, 0xa8, 0xaa,
	0x17, 0x6f, 0x77, 0x26, 0x61, 0x90, 0x67, 0x8c, 0x0e, 0x46, 0xf9, 0xfe, 0x94, 0xd4, 0xf1, 0x61,
	0x33, 0x17, 0x8a, 0x02, 0xc6, 0x19, 0x05, 0x53, 0xa6, 0xea, 0xf3, 0x9a, 0xda, 0x28, 0xe5, 0x7d,
	0xce, 0xe8, 0x64, 0x6c, 0x6e, 0x0b, 0x56, 0xf4, 0x77, 0x81, 0xc5, 0xcd, 0x5a, 0xcb, 0xea, 0xd4,
	0xfc, 0x7a, 0x79, 0xec, 0xc7, 0xce, 0x26, 0xd4, 0x62, 0xcc, 0xe9, 0xb2, 0xb9, 0xa2, 0xc3, 0xe6,
	0xd0, 0xfe, 0x61, 0xc1, 0xfa, 0x5d, 0x87, 0xce, 0x3b, 0xa8, 0xa9, 0x32, 0x52, 0xad, 0xf3, 0xd5,
	0x03, 0x2b, 0xe8, 0x31, 0x1e, 0xca, 0xdb, 0x53, 0x11, 0xa3, 0x6f, 0x34, 0x66, 0xba, 0x09, 0xfd,
	0xc3, 0x74, 0x13, 0x1a, 0xdf, 0x29, 0x69, 0xbe, 0x2e, 0x1a, 0x51, 0x9b, 0x17, 0x01, 0x5a, 0x65,
	0x18, 0x3b, 0xd0, 0x28, 0x38, 0xbb, 0x2e, 0xf4, 0x18, 0xca, 0x69, 0x36, 0xfc, 0x55, 0x13, 0xe8,
	0xc7, 0xbd, 0xf3, 0xcf, 0x67, 0x29, 0xa3, 0xcb, 0xe2, 0xc2, 0x8d, 0xc4, 0xd0, 0x8b, 0x25, 0xde,
	0x5e, 0x79, 0x13, 0xfa, 0x9e, 0x42, 0xf9, 0x85, 0xf1, 0x74, 0x2f, 0x15, 0x5e, 0x7e, 0x95, 0x7a,
	0xf3, 0xfd, 0x1b, 0xfc, 0xb4, 0xac, 0x8b, 0xba, 0x7e, 0x7a, 0xfd, 0x3b, 0x00, 0x00, 0xff, 0xff,
	0x0e, 0xd5, 0xf5, 0x22, 0x41, 0x06, 0x00, 0x00,
}
